/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.phasetwo;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.phasetwo.core.ClientOptions;
import com.phasetwo.core.MediaTypes;
import com.phasetwo.core.ObjectMappers;
import com.phasetwo.core.PhasetwoApiException;
import com.phasetwo.core.PhasetwoClientHttpResponse;
import com.phasetwo.core.PhasetwoException;
import com.phasetwo.core.QueryStringMapper;
import com.phasetwo.core.RequestOptions;
import com.phasetwo.errors.BadRequestError;
import com.phasetwo.errors.ConflictError;
import com.phasetwo.errors.ForbiddenError;
import com.phasetwo.errors.InternalServerError;
import com.phasetwo.errors.NotFoundError;
import com.phasetwo.types.GetAdminRealmsRealmExtAdminUsersRequest;
import com.phasetwo.types.GetAdminRealmsRealmUsersCountRequest;
import com.phasetwo.types.GetAdminRealmsRealmUsersUserIdRequest;
import com.phasetwo.types.MagicLinkRequest;
import com.phasetwo.types.OrganizationRepresentation;
import com.phasetwo.types.OrganizationRoleRepresentation;
import com.phasetwo.types.PutAdminRealmsRealmUsersUserIdExecuteActionsEmailRequest;
import com.phasetwo.types.PutAdminRealmsRealmUsersUserIdSendVerifyEmailRequest;
import com.phasetwo.types.UserRepresentation;
import com.phasetwo.types.UserSessionRepresentation;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.jetbrains.annotations.NotNull;

public class AsyncRawUsersClient {
    protected final ClientOptions clientOptions;

    public AsyncRawUsersClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> createANewUserUsernameMustBeUnique(String realm) {
        return createANewUserUsernameMustBeUnique(
                realm, UserRepresentation.builder().build());
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> createANewUserUsernameMustBeUnique(
            String realm, UserRepresentation request) {
        return createANewUserUsernameMustBeUnique(realm, request, null);
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> createANewUserUsernameMustBeUnique(
            String realm, UserRepresentation request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<Void>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(null, response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 409:
                                future.completeExceptionally(new ConflictError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * It can be called in three different ways. 1. Don’t specify any criteria and pass {@code null}. The number of all users within that realm will be returned. &lt;p&gt; 2. If {@code search} is specified other criteria such as {@code last} will be ignored even though you set them. The {@code search} string will be matched against the first and last name, the username and the email of a user. &lt;p&gt; 3. If {@code search} is unspecified but any of {@code last}, {@code first}, {@code email} or {@code username} those criteria are matched against their respective fields on a user entity. Combined with a logical and.
     */
    public CompletableFuture<PhasetwoClientHttpResponse<Integer>> returnsTheNumberOfUsersThatMatchTheGivenCriteria(
            String realm) {
        return returnsTheNumberOfUsersThatMatchTheGivenCriteria(
                realm, GetAdminRealmsRealmUsersCountRequest.builder().build());
    }

    /**
     * It can be called in three different ways. 1. Don’t specify any criteria and pass {@code null}. The number of all users within that realm will be returned. &lt;p&gt; 2. If {@code search} is specified other criteria such as {@code last} will be ignored even though you set them. The {@code search} string will be matched against the first and last name, the username and the email of a user. &lt;p&gt; 3. If {@code search} is unspecified but any of {@code last}, {@code first}, {@code email} or {@code username} those criteria are matched against their respective fields on a user entity. Combined with a logical and.
     */
    public CompletableFuture<PhasetwoClientHttpResponse<Integer>> returnsTheNumberOfUsersThatMatchTheGivenCriteria(
            String realm, GetAdminRealmsRealmUsersCountRequest request) {
        return returnsTheNumberOfUsersThatMatchTheGivenCriteria(realm, request, null);
    }

    /**
     * It can be called in three different ways. 1. Don’t specify any criteria and pass {@code null}. The number of all users within that realm will be returned. &lt;p&gt; 2. If {@code search} is specified other criteria such as {@code last} will be ignored even though you set them. The {@code search} string will be matched against the first and last name, the username and the email of a user. &lt;p&gt; 3. If {@code search} is unspecified but any of {@code last}, {@code first}, {@code email} or {@code username} those criteria are matched against their respective fields on a user entity. Combined with a logical and.
     */
    public CompletableFuture<PhasetwoClientHttpResponse<Integer>> returnsTheNumberOfUsersThatMatchTheGivenCriteria(
            String realm, GetAdminRealmsRealmUsersCountRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users/count");
        if (request.getEmail().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "email", request.getEmail().get(), false);
        }
        if (request.getEmailVerified().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "emailVerified", request.getEmailVerified().get().toString(), false);
        }
        if (request.getEnabled().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "enabled", request.getEnabled().get().toString(), false);
        }
        if (request.getFirstName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "firstName", request.getFirstName().get(), false);
        }
        if (request.getLastName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lastName", request.getLastName().get(), false);
        }
        if (request.getQ().isPresent()) {
            QueryStringMapper.addQueryParameter(httpUrl, "q", request.getQ().get(), false);
        }
        if (request.getSearch().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "search", request.getSearch().get(), false);
        }
        if (request.getUsername().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "username", request.getUsername().get(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<Integer>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), int.class), response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 403) {
                            future.completeExceptionally(new ForbiddenError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<PhasetwoClientHttpResponse<UserRepresentation>> getRepresentationOfTheUser(
            String realm, String userId) {
        return getRepresentationOfTheUser(
                realm, userId, GetAdminRealmsRealmUsersUserIdRequest.builder().build());
    }

    public CompletableFuture<PhasetwoClientHttpResponse<UserRepresentation>> getRepresentationOfTheUser(
            String realm, String userId, GetAdminRealmsRealmUsersUserIdRequest request) {
        return getRepresentationOfTheUser(realm, userId, request, null);
    }

    public CompletableFuture<PhasetwoClientHttpResponse<UserRepresentation>> getRepresentationOfTheUser(
            String realm, String userId, GetAdminRealmsRealmUsersUserIdRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId);
        if (request.getUserProfileMetadata().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl,
                    "userProfileMetadata",
                    request.getUserProfileMetadata().get().toString(),
                    false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<UserRepresentation>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), UserRepresentation.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 403) {
                            future.completeExceptionally(new ForbiddenError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> updateTheUser(String realm, String userId) {
        return updateTheUser(realm, userId, UserRepresentation.builder().build());
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> updateTheUser(
            String realm, String userId, UserRepresentation request) {
        return updateTheUser(realm, userId, request, null);
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> updateTheUser(
            String realm, String userId, UserRepresentation request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<Void>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(null, response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 409:
                                future.completeExceptionally(new ConflictError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> deleteTheUser(String realm, String userId) {
        return deleteTheUser(realm, userId, null);
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> deleteTheUser(
            String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("DELETE", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<Void>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(null, response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * An email contains a link the user can click to perform a set of required actions. The redirectUri and clientId parameters are optional. If no redirect is given, then there will be no link back to click after actions have completed. Redirect uri must be a valid uri for the particular clientId.
     */
    public CompletableFuture<PhasetwoClientHttpResponse<Void>>
            sendAnEmailToTheUserWithALinkTheyCanClickToExecuteParticularActions(
                    String realm, String userId, PutAdminRealmsRealmUsersUserIdExecuteActionsEmailRequest request) {
        return sendAnEmailToTheUserWithALinkTheyCanClickToExecuteParticularActions(realm, userId, request, null);
    }

    /**
     * An email contains a link the user can click to perform a set of required actions. The redirectUri and clientId parameters are optional. If no redirect is given, then there will be no link back to click after actions have completed. Redirect uri must be a valid uri for the particular clientId.
     */
    public CompletableFuture<PhasetwoClientHttpResponse<Void>>
            sendAnEmailToTheUserWithALinkTheyCanClickToExecuteParticularActions(
                    String realm,
                    String userId,
                    PutAdminRealmsRealmUsersUserIdExecuteActionsEmailRequest request,
                    RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("execute-actions-email");
        if (request.getClientId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "client_id", request.getClientId().get(), false);
        }
        if (request.getLifespan().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lifespan", request.getLifespan().get().toString(), false);
        }
        if (request.getRedirectUri().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "redirect_uri", request.getRedirectUri().get(), false);
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request.getBody()), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<Void>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(null, response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Map<String, Object>>> impersonateTheUser(
            String realm, String userId) {
        return impersonateTheUser(realm, userId, null);
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Map<String, Object>>> impersonateTheUser(
            String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("impersonation")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<Map<String, Object>>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), new TypeReference<Map<String, Object>>() {}),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>>
            removeAllUserSessionsAssociatedWithTheUserAlsoSendNotificationToAllClientsThatHaveAnAdminUrlToInvalidateTheSessionsForTheParticularUser(
                    String realm, String userId) {
        return removeAllUserSessionsAssociatedWithTheUserAlsoSendNotificationToAllClientsThatHaveAnAdminUrlToInvalidateTheSessionsForTheParticularUser(
                realm, userId, null);
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>>
            removeAllUserSessionsAssociatedWithTheUserAlsoSendNotificationToAllClientsThatHaveAnAdminUrlToInvalidateTheSessionsForTheParticularUser(
                    String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("logout")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<Void>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(null, response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 403) {
                            future.completeExceptionally(new ForbiddenError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * The redirectUri, clientId and lifespan parameters are optional. The default for the redirect is the account client. The default for the lifespan is 12 hours
     */
    public CompletableFuture<PhasetwoClientHttpResponse<Void>>
            sendAnEmailVerificationEmailToTheUserAnEmailContainsALinkTheUserCanClickToVerifyTheirEmailAddress(
                    String realm, String userId) {
        return sendAnEmailVerificationEmailToTheUserAnEmailContainsALinkTheUserCanClickToVerifyTheirEmailAddress(
                realm,
                userId,
                PutAdminRealmsRealmUsersUserIdSendVerifyEmailRequest.builder().build());
    }

    /**
     * The redirectUri, clientId and lifespan parameters are optional. The default for the redirect is the account client. The default for the lifespan is 12 hours
     */
    public CompletableFuture<PhasetwoClientHttpResponse<Void>>
            sendAnEmailVerificationEmailToTheUserAnEmailContainsALinkTheUserCanClickToVerifyTheirEmailAddress(
                    String realm, String userId, PutAdminRealmsRealmUsersUserIdSendVerifyEmailRequest request) {
        return sendAnEmailVerificationEmailToTheUserAnEmailContainsALinkTheUserCanClickToVerifyTheirEmailAddress(
                realm, userId, request, null);
    }

    /**
     * The redirectUri, clientId and lifespan parameters are optional. The default for the redirect is the account client. The default for the lifespan is 12 hours
     */
    public CompletableFuture<PhasetwoClientHttpResponse<Void>>
            sendAnEmailVerificationEmailToTheUserAnEmailContainsALinkTheUserCanClickToVerifyTheirEmailAddress(
                    String realm,
                    String userId,
                    PutAdminRealmsRealmUsersUserIdSendVerifyEmailRequest request,
                    RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("send-verify-email");
        if (request.getClientId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "client_id", request.getClientId().get(), false);
        }
        if (request.getLifespan().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lifespan", request.getLifespan().get().toString(), false);
        }
        if (request.getRedirectUri().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "redirect_uri", request.getRedirectUri().get(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("PUT", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<Void>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(null, response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new InternalServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<PhasetwoClientHttpResponse<List<UserSessionRepresentation>>>
            getSessionsAssociatedWithTheUser(String realm, String userId) {
        return getSessionsAssociatedWithTheUser(realm, userId, null);
    }

    public CompletableFuture<PhasetwoClientHttpResponse<List<UserSessionRepresentation>>>
            getSessionsAssociatedWithTheUser(String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("sessions")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<List<UserSessionRepresentation>>> future =
                new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), new TypeReference<List<UserSessionRepresentation>>() {}),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 403) {
                            future.completeExceptionally(new ForbiddenError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<PhasetwoClientHttpResponse<List<OrganizationRepresentation>>>
            listOrganizationsForTheGivenUser(String realm, String userId) {
        return listOrganizationsForTheGivenUser(realm, userId, null);
    }

    public CompletableFuture<PhasetwoClientHttpResponse<List<OrganizationRepresentation>>>
            listOrganizationsForTheGivenUser(String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("orgs")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<List<OrganizationRepresentation>>> future =
                new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(),
                                        new TypeReference<List<OrganizationRepresentation>>() {}),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<PhasetwoClientHttpResponse<List<OrganizationRoleRepresentation>>>
            listOrganizationRolesForTheGivenUserAndOrg(String realm, String userId, String orgId) {
        return listOrganizationRolesForTheGivenUserAndOrg(realm, userId, orgId, null);
    }

    public CompletableFuture<PhasetwoClientHttpResponse<List<OrganizationRoleRepresentation>>>
            listOrganizationRolesForTheGivenUserAndOrg(
                    String realm, String userId, String orgId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("orgs")
                .addPathSegment(orgId)
                .addPathSegments("roles")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<List<OrganizationRoleRepresentation>>> future =
                new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(),
                                        new TypeReference<List<OrganizationRoleRepresentation>>() {}),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> grantAUserOrganizationRoles(
            String realm, String userId, String orgId, List<OrganizationRoleRepresentation> request) {
        return grantAUserOrganizationRoles(realm, userId, orgId, request, null);
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> grantAUserOrganizationRoles(
            String realm,
            String userId,
            String orgId,
            List<OrganizationRoleRepresentation> request,
            RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("orgs")
                .addPathSegment(orgId)
                .addPathSegments("roles")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<Void>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(null, response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> revokeOrganizationRolesFromAUser(
            String realm, String userId, String orgId, List<OrganizationRoleRepresentation> request) {
        return revokeOrganizationRolesFromAUser(realm, userId, orgId, request, null);
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> revokeOrganizationRolesFromAUser(
            String realm,
            String userId,
            String orgId,
            List<OrganizationRoleRepresentation> request,
            RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("orgs")
                .addPathSegment(orgId)
                .addPathSegments("roles")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PATCH", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<Void>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(null, response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> createMagicLink(String realm, MagicLinkRequest request) {
        return createMagicLink(realm, request, null);
    }

    public CompletableFuture<PhasetwoClientHttpResponse<Void>> createMagicLink(
            String realm, MagicLinkRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("realms")
                .addPathSegment(realm)
                .addPathSegments("magic-link")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<Void>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(null, response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Returns a stream of users, filtered according to query parameters.
     */
    public CompletableFuture<PhasetwoClientHttpResponse<List<UserRepresentation>>> getUsers(String realm) {
        return getUsers(realm, GetAdminRealmsRealmExtAdminUsersRequest.builder().build());
    }

    /**
     * Returns a stream of users, filtered according to query parameters.
     */
    public CompletableFuture<PhasetwoClientHttpResponse<List<UserRepresentation>>> getUsers(
            String realm, GetAdminRealmsRealmExtAdminUsersRequest request) {
        return getUsers(realm, request, null);
    }

    /**
     * Returns a stream of users, filtered according to query parameters.
     */
    public CompletableFuture<PhasetwoClientHttpResponse<List<UserRepresentation>>> getUsers(
            String realm, GetAdminRealmsRealmExtAdminUsersRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("ext-admin/users");
        if (request.getBriefRepresentation().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl,
                    "briefRepresentation",
                    request.getBriefRepresentation().get().toString(),
                    false);
        }
        if (request.getEmail().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "email", request.getEmail().get(), false);
        }
        if (request.getEmailVerified().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "emailVerified", request.getEmailVerified().get().toString(), false);
        }
        if (request.getEnabled().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "enabled", request.getEnabled().get().toString(), false);
        }
        if (request.getExact().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "exact", request.getExact().get().toString(), false);
        }
        if (request.getFirst().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "first", request.getFirst().get().toString(), false);
        }
        if (request.getFirstName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "firstName", request.getFirstName().get(), false);
        }
        if (request.getIdpAlias().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "idpAlias", request.getIdpAlias().get(), false);
        }
        if (request.getIdpUserId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "idpUserId", request.getIdpUserId().get(), false);
        }
        if (request.getLastName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lastName", request.getLastName().get(), false);
        }
        if (request.getMax().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "max", request.getMax().get().toString(), false);
        }
        if (request.getQ().isPresent()) {
            QueryStringMapper.addQueryParameter(httpUrl, "q", request.getQ().get(), false);
        }
        if (request.getSearch().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "search", request.getSearch().get(), false);
        }
        if (request.getUsername().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "username", request.getUsername().get(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<PhasetwoClientHttpResponse<List<UserRepresentation>>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new PhasetwoClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), new TypeReference<List<UserRepresentation>>() {}),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    future.completeExceptionally(new PhasetwoApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new PhasetwoException("Network error executing HTTP request", e));
            }
        });
        return future;
    }
}
