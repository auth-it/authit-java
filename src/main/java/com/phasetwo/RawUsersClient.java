/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.phasetwo;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.phasetwo.core.ClientOptions;
import com.phasetwo.core.MediaTypes;
import com.phasetwo.core.ObjectMappers;
import com.phasetwo.core.PhasetwoApiException;
import com.phasetwo.core.PhasetwoClientHttpResponse;
import com.phasetwo.core.PhasetwoException;
import com.phasetwo.core.QueryStringMapper;
import com.phasetwo.core.RequestOptions;
import com.phasetwo.errors.BadRequestError;
import com.phasetwo.errors.ConflictError;
import com.phasetwo.errors.ForbiddenError;
import com.phasetwo.errors.InternalServerError;
import com.phasetwo.errors.NotFoundError;
import com.phasetwo.types.ActiveOrganizationRepresentation;
import com.phasetwo.types.CredentialRepresentation;
import com.phasetwo.types.FederatedIdentityRepresentation;
import com.phasetwo.types.GetAdminRealmsRealmExtAdminUsersRequest;
import com.phasetwo.types.GetAdminRealmsRealmUsersCountRequest;
import com.phasetwo.types.GetAdminRealmsRealmUsersUserIdRequest;
import com.phasetwo.types.MagicLinkRequest;
import com.phasetwo.types.OrganizationRepresentation;
import com.phasetwo.types.OrganizationRoleRepresentation;
import com.phasetwo.types.PutAdminRealmsRealmUsersUserIdExecuteActionsEmailRequest;
import com.phasetwo.types.PutAdminRealmsRealmUsersUserIdResetPasswordEmailRequest;
import com.phasetwo.types.PutAdminRealmsRealmUsersUserIdSendVerifyEmailRequest;
import com.phasetwo.types.SwitchOrganizationRepresentation;
import com.phasetwo.types.UpConfig;
import com.phasetwo.types.UserProfileMetadata;
import com.phasetwo.types.UserRepresentation;
import com.phasetwo.types.UserSessionRepresentation;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;

public class RawUsersClient {
    protected final ClientOptions clientOptions;

    public RawUsersClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    public PhasetwoClientHttpResponse<Void> createANewUserUsernameMustBeUnique(String realm) {
        return createANewUserUsernameMustBeUnique(
                realm, UserRepresentation.builder().build());
    }

    public PhasetwoClientHttpResponse<Void> createANewUserUsernameMustBeUnique(
            String realm, UserRepresentation request) {
        return createANewUserUsernameMustBeUnique(realm, request, null);
    }

    public PhasetwoClientHttpResponse<Void> createANewUserUsernameMustBeUnique(
            String realm, UserRepresentation request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 409:
                        throw new ConflictError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 500:
                        throw new InternalServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    /**
     * It can be called in three different ways. 1. Don’t specify any criteria and pass {@code null}. The number of all users within that realm will be returned. &lt;p&gt; 2. If {@code search} is specified other criteria such as {@code last} will be ignored even though you set them. The {@code search} string will be matched against the first and last name, the username and the email of a user. &lt;p&gt; 3. If {@code search} is unspecified but any of {@code last}, {@code first}, {@code email} or {@code username} those criteria are matched against their respective fields on a user entity. Combined with a logical and.
     */
    public PhasetwoClientHttpResponse<Integer> returnsTheNumberOfUsersThatMatchTheGivenCriteria(String realm) {
        return returnsTheNumberOfUsersThatMatchTheGivenCriteria(
                realm, GetAdminRealmsRealmUsersCountRequest.builder().build());
    }

    /**
     * It can be called in three different ways. 1. Don’t specify any criteria and pass {@code null}. The number of all users within that realm will be returned. &lt;p&gt; 2. If {@code search} is specified other criteria such as {@code last} will be ignored even though you set them. The {@code search} string will be matched against the first and last name, the username and the email of a user. &lt;p&gt; 3. If {@code search} is unspecified but any of {@code last}, {@code first}, {@code email} or {@code username} those criteria are matched against their respective fields on a user entity. Combined with a logical and.
     */
    public PhasetwoClientHttpResponse<Integer> returnsTheNumberOfUsersThatMatchTheGivenCriteria(
            String realm, GetAdminRealmsRealmUsersCountRequest request) {
        return returnsTheNumberOfUsersThatMatchTheGivenCriteria(realm, request, null);
    }

    /**
     * It can be called in three different ways. 1. Don’t specify any criteria and pass {@code null}. The number of all users within that realm will be returned. &lt;p&gt; 2. If {@code search} is specified other criteria such as {@code last} will be ignored even though you set them. The {@code search} string will be matched against the first and last name, the username and the email of a user. &lt;p&gt; 3. If {@code search} is unspecified but any of {@code last}, {@code first}, {@code email} or {@code username} those criteria are matched against their respective fields on a user entity. Combined with a logical and.
     */
    public PhasetwoClientHttpResponse<Integer> returnsTheNumberOfUsersThatMatchTheGivenCriteria(
            String realm, GetAdminRealmsRealmUsersCountRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users/count");
        if (request.getEmail().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "email", request.getEmail().get(), false);
        }
        if (request.getEmailVerified().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "emailVerified", request.getEmailVerified().get().toString(), false);
        }
        if (request.getEnabled().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "enabled", request.getEnabled().get().toString(), false);
        }
        if (request.getFirstName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "firstName", request.getFirstName().get(), false);
        }
        if (request.getLastName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lastName", request.getLastName().get(), false);
        }
        if (request.getQ().isPresent()) {
            QueryStringMapper.addQueryParameter(httpUrl, "q", request.getQ().get(), false);
        }
        if (request.getSearch().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "search", request.getSearch().get(), false);
        }
        if (request.getUsername().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "username", request.getUsername().get(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), int.class), response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                if (response.code() == 403) {
                    throw new ForbiddenError(
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    /**
     * Get the configuration for the user profile
     */
    public PhasetwoClientHttpResponse<UpConfig> getAdminRealmsRealmUsersProfile(String realm) {
        return getAdminRealmsRealmUsersProfile(realm, null);
    }

    /**
     * Get the configuration for the user profile
     */
    public PhasetwoClientHttpResponse<UpConfig> getAdminRealmsRealmUsersProfile(
            String realm, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users/profile")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), UpConfig.class), response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                if (response.code() == 403) {
                    throw new ForbiddenError(
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    /**
     * Set the configuration for the user profile
     */
    public PhasetwoClientHttpResponse<UpConfig> putAdminRealmsRealmUsersProfile(String realm) {
        return putAdminRealmsRealmUsersProfile(realm, UpConfig.builder().build());
    }

    /**
     * Set the configuration for the user profile
     */
    public PhasetwoClientHttpResponse<UpConfig> putAdminRealmsRealmUsersProfile(String realm, UpConfig request) {
        return putAdminRealmsRealmUsersProfile(realm, request, null);
    }

    /**
     * Set the configuration for the user profile
     */
    public PhasetwoClientHttpResponse<UpConfig> putAdminRealmsRealmUsersProfile(
            String realm, UpConfig request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users/profile")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), UpConfig.class), response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                if (response.code() == 403) {
                    throw new ForbiddenError(
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    /**
     * Get the UserProfileMetadata from the configuration
     */
    public PhasetwoClientHttpResponse<UserProfileMetadata> getAdminRealmsRealmUsersProfileMetadata(String realm) {
        return getAdminRealmsRealmUsersProfileMetadata(realm, null);
    }

    /**
     * Get the UserProfileMetadata from the configuration
     */
    public PhasetwoClientHttpResponse<UserProfileMetadata> getAdminRealmsRealmUsersProfileMetadata(
            String realm, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users/profile/metadata")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), UserProfileMetadata.class),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                if (response.code() == 403) {
                    throw new ForbiddenError(
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<UserRepresentation> getRepresentationOfTheUser(String realm, String userId) {
        return getRepresentationOfTheUser(
                realm, userId, GetAdminRealmsRealmUsersUserIdRequest.builder().build());
    }

    public PhasetwoClientHttpResponse<UserRepresentation> getRepresentationOfTheUser(
            String realm, String userId, GetAdminRealmsRealmUsersUserIdRequest request) {
        return getRepresentationOfTheUser(realm, userId, request, null);
    }

    public PhasetwoClientHttpResponse<UserRepresentation> getRepresentationOfTheUser(
            String realm, String userId, GetAdminRealmsRealmUsersUserIdRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId);
        if (request.getUserProfileMetadata().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl,
                    "userProfileMetadata",
                    request.getUserProfileMetadata().get().toString(),
                    false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), UserRepresentation.class), response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                if (response.code() == 403) {
                    throw new ForbiddenError(
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Void> updateTheUser(String realm, String userId) {
        return updateTheUser(realm, userId, UserRepresentation.builder().build());
    }

    public PhasetwoClientHttpResponse<Void> updateTheUser(String realm, String userId, UserRepresentation request) {
        return updateTheUser(realm, userId, request, null);
    }

    public PhasetwoClientHttpResponse<Void> updateTheUser(
            String realm, String userId, UserRepresentation request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 409:
                        throw new ConflictError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 500:
                        throw new InternalServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Void> deleteTheUser(String realm, String userId) {
        return deleteTheUser(realm, userId, null);
    }

    public PhasetwoClientHttpResponse<Void> deleteTheUser(String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("DELETE", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    /**
     * Returned values can contain for example &quot;password&quot;, &quot;otp&quot; etc. This will always return empty list for &quot;local&quot; users, which are not backed by any user storage
     */
    public PhasetwoClientHttpResponse<List<String>>
            returnCredentialTypesWhichAreProvidedByTheUserStorageWhereUserIsStored(String realm, String userId) {
        return returnCredentialTypesWhichAreProvidedByTheUserStorageWhereUserIsStored(realm, userId, null);
    }

    /**
     * Returned values can contain for example &quot;password&quot;, &quot;otp&quot; etc. This will always return empty list for &quot;local&quot; users, which are not backed by any user storage
     */
    public PhasetwoClientHttpResponse<List<String>>
            returnCredentialTypesWhichAreProvidedByTheUserStorageWhereUserIsStored(
                    String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("configured-user-storage-credential-types")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), new TypeReference<List<String>>() {}),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                if (response.code() == 403) {
                    throw new ForbiddenError(
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<List<CredentialRepresentation>> getAdminRealmsRealmUsersUserIdCredentials(
            String realm, String userId) {
        return getAdminRealmsRealmUsersUserIdCredentials(realm, userId, null);
    }

    public PhasetwoClientHttpResponse<List<CredentialRepresentation>> getAdminRealmsRealmUsersUserIdCredentials(
            String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("credentials")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), new TypeReference<List<CredentialRepresentation>>() {}),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                if (response.code() == 403) {
                    throw new ForbiddenError(
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Void> removeACredentialForAUser(
            String realm, String userId, String credentialId) {
        return removeACredentialForAUser(realm, userId, credentialId, null);
    }

    public PhasetwoClientHttpResponse<Void> removeACredentialForAUser(
            String realm, String userId, String credentialId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("credentials")
                .addPathSegment(credentialId)
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("DELETE", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Void> updateACredentialLabelForAUser(
            String realm, String userId, String credentialId) {
        return updateACredentialLabelForAUser(realm, userId, credentialId, null);
    }

    public PhasetwoClientHttpResponse<Void> updateACredentialLabelForAUser(
            String realm, String userId, String credentialId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("credentials")
                .addPathSegment(credentialId)
                .addPathSegments("userLabel")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Void> disableAllCredentialsForAUserOfASpecificType(
            String realm, String userId, List<String> request) {
        return disableAllCredentialsForAUserOfASpecificType(realm, userId, request, null);
    }

    public PhasetwoClientHttpResponse<Void> disableAllCredentialsForAUserOfASpecificType(
            String realm, String userId, List<String> request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("disable-credential-types")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                if (response.code() == 403) {
                    throw new ForbiddenError(
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    /**
     * An email contains a link the user can click to perform a set of required actions. The redirectUri and clientId parameters are optional. If no redirect is given, then there will be no link back to click after actions have completed. Redirect uri must be a valid uri for the particular clientId.
     */
    public PhasetwoClientHttpResponse<Void> sendAnEmailToTheUserWithALinkTheyCanClickToExecuteParticularActions(
            String realm, String userId, PutAdminRealmsRealmUsersUserIdExecuteActionsEmailRequest request) {
        return sendAnEmailToTheUserWithALinkTheyCanClickToExecuteParticularActions(realm, userId, request, null);
    }

    /**
     * An email contains a link the user can click to perform a set of required actions. The redirectUri and clientId parameters are optional. If no redirect is given, then there will be no link back to click after actions have completed. Redirect uri must be a valid uri for the particular clientId.
     */
    public PhasetwoClientHttpResponse<Void> sendAnEmailToTheUserWithALinkTheyCanClickToExecuteParticularActions(
            String realm,
            String userId,
            PutAdminRealmsRealmUsersUserIdExecuteActionsEmailRequest request,
            RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("execute-actions-email");
        if (request.getClientId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "client_id", request.getClientId().get(), false);
        }
        if (request.getLifespan().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lifespan", request.getLifespan().get().toString(), false);
        }
        if (request.getRedirectUri().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "redirect_uri", request.getRedirectUri().get(), false);
        }
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request.getBody()), MediaTypes.APPLICATION_JSON);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 500:
                        throw new InternalServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<List<FederatedIdentityRepresentation>> getSocialLoginsAssociatedWithTheUser(
            String realm, String userId) {
        return getSocialLoginsAssociatedWithTheUser(realm, userId, null);
    }

    public PhasetwoClientHttpResponse<List<FederatedIdentityRepresentation>> getSocialLoginsAssociatedWithTheUser(
            String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("federated-identity")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), new TypeReference<List<FederatedIdentityRepresentation>>() {}),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                if (response.code() == 403) {
                    throw new ForbiddenError(
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Void> addASocialLoginProviderToTheUser(
            String realm, String userId, String provider) {
        return addASocialLoginProviderToTheUser(realm, userId, provider, null);
    }

    public PhasetwoClientHttpResponse<Void> addASocialLoginProviderToTheUser(
            String realm, String userId, String provider, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("federated-identity")
                .addPathSegment(provider)
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 409:
                        throw new ConflictError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Void> removeASocialLoginProviderFromUser(
            String realm, String userId, String provider) {
        return removeASocialLoginProviderFromUser(realm, userId, provider, null);
    }

    public PhasetwoClientHttpResponse<Void> removeASocialLoginProviderFromUser(
            String realm, String userId, String provider, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("federated-identity")
                .addPathSegment(provider)
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("DELETE", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Map<String, Object>> impersonateTheUser(String realm, String userId) {
        return impersonateTheUser(realm, userId, null);
    }

    public PhasetwoClientHttpResponse<Map<String, Object>> impersonateTheUser(
            String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("impersonation")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), new TypeReference<Map<String, Object>>() {}),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Void>
            removeAllUserSessionsAssociatedWithTheUserAlsoSendNotificationToAllClientsThatHaveAnAdminUrlToInvalidateTheSessionsForTheParticularUser(
                    String realm, String userId) {
        return removeAllUserSessionsAssociatedWithTheUserAlsoSendNotificationToAllClientsThatHaveAnAdminUrlToInvalidateTheSessionsForTheParticularUser(
                realm, userId, null);
    }

    public PhasetwoClientHttpResponse<Void>
            removeAllUserSessionsAssociatedWithTheUserAlsoSendNotificationToAllClientsThatHaveAnAdminUrlToInvalidateTheSessionsForTheParticularUser(
                    String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("logout")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                if (response.code() == 403) {
                    throw new ForbiddenError(
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<List<UserSessionRepresentation>> getOfflineSessionsAssociatedWithTheUserAndClient(
            String realm, String userId, String clientUuid) {
        return getOfflineSessionsAssociatedWithTheUserAndClient(realm, userId, clientUuid, null);
    }

    public PhasetwoClientHttpResponse<List<UserSessionRepresentation>> getOfflineSessionsAssociatedWithTheUserAndClient(
            String realm, String userId, String clientUuid, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("offline-sessions")
                .addPathSegment(clientUuid)
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), new TypeReference<List<UserSessionRepresentation>>() {}),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Void> setUpANewPasswordForTheUser(String realm, String userId) {
        return setUpANewPasswordForTheUser(
                realm, userId, CredentialRepresentation.builder().build());
    }

    public PhasetwoClientHttpResponse<Void> setUpANewPasswordForTheUser(
            String realm, String userId, CredentialRepresentation request) {
        return setUpANewPasswordForTheUser(realm, userId, request, null);
    }

    public PhasetwoClientHttpResponse<Void> setUpANewPasswordForTheUser(
            String realm, String userId, CredentialRepresentation request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("reset-password")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 500:
                        throw new InternalServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    /**
     * The redirectUri and clientId parameters are optional. The default for the redirect is the account client. This endpoint has been deprecated.  Please use the execute-actions-email passing a list with UPDATE_PASSWORD within it.
     */
    public PhasetwoClientHttpResponse<Void> sendAnEmailToTheUserWithALinkTheyCanClickToResetTheirPassword(
            String realm, String userId) {
        return sendAnEmailToTheUserWithALinkTheyCanClickToResetTheirPassword(
                realm,
                userId,
                PutAdminRealmsRealmUsersUserIdResetPasswordEmailRequest.builder()
                        .build());
    }

    /**
     * The redirectUri and clientId parameters are optional. The default for the redirect is the account client. This endpoint has been deprecated.  Please use the execute-actions-email passing a list with UPDATE_PASSWORD within it.
     */
    public PhasetwoClientHttpResponse<Void> sendAnEmailToTheUserWithALinkTheyCanClickToResetTheirPassword(
            String realm, String userId, PutAdminRealmsRealmUsersUserIdResetPasswordEmailRequest request) {
        return sendAnEmailToTheUserWithALinkTheyCanClickToResetTheirPassword(realm, userId, request, null);
    }

    /**
     * The redirectUri and clientId parameters are optional. The default for the redirect is the account client. This endpoint has been deprecated.  Please use the execute-actions-email passing a list with UPDATE_PASSWORD within it.
     */
    public PhasetwoClientHttpResponse<Void> sendAnEmailToTheUserWithALinkTheyCanClickToResetTheirPassword(
            String realm,
            String userId,
            PutAdminRealmsRealmUsersUserIdResetPasswordEmailRequest request,
            RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("reset-password-email");
        if (request.getClientId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "client_id", request.getClientId().get(), false);
        }
        if (request.getRedirectUri().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "redirect_uri", request.getRedirectUri().get(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("PUT", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 500:
                        throw new InternalServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    /**
     * The redirectUri, clientId and lifespan parameters are optional. The default for the redirect is the account client. The default for the lifespan is 12 hours
     */
    public PhasetwoClientHttpResponse<Void>
            sendAnEmailVerificationEmailToTheUserAnEmailContainsALinkTheUserCanClickToVerifyTheirEmailAddress(
                    String realm, String userId) {
        return sendAnEmailVerificationEmailToTheUserAnEmailContainsALinkTheUserCanClickToVerifyTheirEmailAddress(
                realm,
                userId,
                PutAdminRealmsRealmUsersUserIdSendVerifyEmailRequest.builder().build());
    }

    /**
     * The redirectUri, clientId and lifespan parameters are optional. The default for the redirect is the account client. The default for the lifespan is 12 hours
     */
    public PhasetwoClientHttpResponse<Void>
            sendAnEmailVerificationEmailToTheUserAnEmailContainsALinkTheUserCanClickToVerifyTheirEmailAddress(
                    String realm, String userId, PutAdminRealmsRealmUsersUserIdSendVerifyEmailRequest request) {
        return sendAnEmailVerificationEmailToTheUserAnEmailContainsALinkTheUserCanClickToVerifyTheirEmailAddress(
                realm, userId, request, null);
    }

    /**
     * The redirectUri, clientId and lifespan parameters are optional. The default for the redirect is the account client. The default for the lifespan is 12 hours
     */
    public PhasetwoClientHttpResponse<Void>
            sendAnEmailVerificationEmailToTheUserAnEmailContainsALinkTheUserCanClickToVerifyTheirEmailAddress(
                    String realm,
                    String userId,
                    PutAdminRealmsRealmUsersUserIdSendVerifyEmailRequest request,
                    RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("send-verify-email");
        if (request.getClientId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "client_id", request.getClientId().get(), false);
        }
        if (request.getLifespan().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lifespan", request.getLifespan().get().toString(), false);
        }
        if (request.getRedirectUri().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "redirect_uri", request.getRedirectUri().get(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("PUT", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 500:
                        throw new InternalServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<List<UserSessionRepresentation>> getSessionsAssociatedWithTheUser(
            String realm, String userId) {
        return getSessionsAssociatedWithTheUser(realm, userId, null);
    }

    public PhasetwoClientHttpResponse<List<UserSessionRepresentation>> getSessionsAssociatedWithTheUser(
            String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("sessions")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), new TypeReference<List<UserSessionRepresentation>>() {}),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                if (response.code() == 403) {
                    throw new ForbiddenError(
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Map<String, List<String>>> getAdminRealmsRealmUsersUserIdUnmanagedAttributes(
            String realm, String userId) {
        return getAdminRealmsRealmUsersUserIdUnmanagedAttributes(realm, userId, null);
    }

    public PhasetwoClientHttpResponse<Map<String, List<String>>> getAdminRealmsRealmUsersUserIdUnmanagedAttributes(
            String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("unmanagedAttributes")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), new TypeReference<Map<String, List<String>>>() {}),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                if (response.code() == 403) {
                    throw new ForbiddenError(
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<List<OrganizationRepresentation>> listOrganizationsForTheGivenUser(
            String realm, String userId) {
        return listOrganizationsForTheGivenUser(realm, userId, null);
    }

    public PhasetwoClientHttpResponse<List<OrganizationRepresentation>> listOrganizationsForTheGivenUser(
            String realm, String userId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("orgs")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), new TypeReference<List<OrganizationRepresentation>>() {}),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<List<OrganizationRoleRepresentation>> listOrganizationRolesForTheGivenUserAndOrg(
            String realm, String userId, String orgId) {
        return listOrganizationRolesForTheGivenUserAndOrg(realm, userId, orgId, null);
    }

    public PhasetwoClientHttpResponse<List<OrganizationRoleRepresentation>> listOrganizationRolesForTheGivenUserAndOrg(
            String realm, String userId, String orgId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("orgs")
                .addPathSegment(orgId)
                .addPathSegments("roles")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), new TypeReference<List<OrganizationRoleRepresentation>>() {}),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Void> grantAUserOrganizationRoles(
            String realm, String userId, String orgId, List<OrganizationRoleRepresentation> request) {
        return grantAUserOrganizationRoles(realm, userId, orgId, request, null);
    }

    public PhasetwoClientHttpResponse<Void> grantAUserOrganizationRoles(
            String realm,
            String userId,
            String orgId,
            List<OrganizationRoleRepresentation> request,
            RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("orgs")
                .addPathSegment(orgId)
                .addPathSegments("roles")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Void> revokeOrganizationRolesFromAUser(
            String realm, String userId, String orgId, List<OrganizationRoleRepresentation> request) {
        return revokeOrganizationRolesFromAUser(realm, userId, orgId, request, null);
    }

    public PhasetwoClientHttpResponse<Void> revokeOrganizationRolesFromAUser(
            String realm,
            String userId,
            String orgId,
            List<OrganizationRoleRepresentation> request,
            RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("realms")
                .addPathSegment(realm)
                .addPathSegments("users")
                .addPathSegment(userId)
                .addPathSegments("orgs")
                .addPathSegment(orgId)
                .addPathSegments("roles")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PATCH", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    /**
     * Switch the active organization context for the authenticated user
     */
    public PhasetwoClientHttpResponse<Void> switchActiveOrganization(
            String realm, SwitchOrganizationRepresentation request) {
        return switchActiveOrganization(realm, request, null);
    }

    /**
     * Switch the active organization context for the authenticated user
     */
    public PhasetwoClientHttpResponse<Void> switchActiveOrganization(
            String realm, SwitchOrganizationRepresentation request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("realms")
                .addPathSegment(realm)
                .addPathSegments("users/switch-organization")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 403:
                        throw new ForbiddenError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    /**
     * Get the currently active organization for the authenticated user
     */
    public PhasetwoClientHttpResponse<ActiveOrganizationRepresentation> getActiveOrganization(String realm) {
        return getActiveOrganization(realm, null);
    }

    /**
     * Get the currently active organization for the authenticated user
     */
    public PhasetwoClientHttpResponse<ActiveOrganizationRepresentation> getActiveOrganization(
            String realm, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("realms")
                .addPathSegment(realm)
                .addPathSegments("users/active-organization")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), ActiveOrganizationRepresentation.class),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    public PhasetwoClientHttpResponse<Void> createMagicLink(String realm, MagicLinkRequest request) {
        return createMagicLink(realm, request, null);
    }

    public PhasetwoClientHttpResponse<Void> createMagicLink(
            String realm, MagicLinkRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("realms")
                .addPathSegment(realm)
                .addPathSegments("magic-link")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new PhasetwoException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }

    /**
     * Returns a stream of users, filtered according to query parameters.
     */
    public PhasetwoClientHttpResponse<List<UserRepresentation>> getUsers(String realm) {
        return getUsers(realm, GetAdminRealmsRealmExtAdminUsersRequest.builder().build());
    }

    /**
     * Returns a stream of users, filtered according to query parameters.
     */
    public PhasetwoClientHttpResponse<List<UserRepresentation>> getUsers(
            String realm, GetAdminRealmsRealmExtAdminUsersRequest request) {
        return getUsers(realm, request, null);
    }

    /**
     * Returns a stream of users, filtered according to query parameters.
     */
    public PhasetwoClientHttpResponse<List<UserRepresentation>> getUsers(
            String realm, GetAdminRealmsRealmExtAdminUsersRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("ext-admin/users");
        if (request.getBriefRepresentation().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl,
                    "briefRepresentation",
                    request.getBriefRepresentation().get().toString(),
                    false);
        }
        if (request.getEmail().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "email", request.getEmail().get(), false);
        }
        if (request.getEmailVerified().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "emailVerified", request.getEmailVerified().get().toString(), false);
        }
        if (request.getEnabled().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "enabled", request.getEnabled().get().toString(), false);
        }
        if (request.getExact().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "exact", request.getExact().get().toString(), false);
        }
        if (request.getFirst().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "first", request.getFirst().get().toString(), false);
        }
        if (request.getFirstName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "firstName", request.getFirstName().get(), false);
        }
        if (request.getIdpAlias().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "idpAlias", request.getIdpAlias().get(), false);
        }
        if (request.getIdpUserId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "idpUserId", request.getIdpUserId().get(), false);
        }
        if (request.getLastName().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "lastName", request.getLastName().get(), false);
        }
        if (request.getMax().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "max", request.getMax().get().toString(), false);
        }
        if (request.getQ().isPresent()) {
            QueryStringMapper.addQueryParameter(httpUrl, "q", request.getQ().get(), false);
        }
        if (request.getSearch().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "search", request.getSearch().get(), false);
        }
        if (request.getUsername().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "username", request.getUsername().get(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new PhasetwoClientHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), new TypeReference<List<UserRepresentation>>() {}),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            throw new PhasetwoApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new PhasetwoException("Network error executing HTTP request", e);
        }
    }
}
