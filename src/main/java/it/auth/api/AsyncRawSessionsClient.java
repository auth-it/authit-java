/**
 * This file was auto-generated by Fern from our API Definition.
 */
package it.auth.api;

import com.fasterxml.jackson.core.JsonProcessingException;
import it.auth.api.core.AuthItApiException;
import it.auth.api.core.AuthItClientHttpResponse;
import it.auth.api.core.AuthItException;
import it.auth.api.core.ClientOptions;
import it.auth.api.core.ObjectMappers;
import it.auth.api.core.QueryStringMapper;
import it.auth.api.core.RequestOptions;
import it.auth.api.errors.ForbiddenError;
import it.auth.api.errors.NotFoundError;
import it.auth.api.types.GlobalRequestResult;
import it.auth.api.types.RemoveUserSessionRequest;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.jetbrains.annotations.NotNull;

public class AsyncRawSessionsClient {
    protected final ClientOptions clientOptions;

    public AsyncRawSessionsClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * Remove all user sessions for this realm. Any client that has an admin url will also be told to invalidate any sessions they have. For large numbers of sessions, this can take a long period to execute.
     */
    public CompletableFuture<AuthItClientHttpResponse<GlobalRequestResult>> removeAllSessions(String realm) {
        return removeAllSessions(realm, null);
    }

    /**
     * Remove all user sessions for this realm. Any client that has an admin url will also be told to invalidate any sessions they have. For large numbers of sessions, this can take a long period to execute.
     */
    public CompletableFuture<AuthItClientHttpResponse<GlobalRequestResult>> removeAllSessions(
            String realm, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("logout-all")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<AuthItClientHttpResponse<GlobalRequestResult>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new AuthItClientHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), GlobalRequestResult.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        if (response.code() == 403) {
                            future.completeExceptionally(new ForbiddenError(
                                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class), response));
                            return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new AuthItApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new AuthItException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new AuthItException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Remove a specific user session. Any client that has an admin url will also be told to invalidate this particular session.
     */
    public CompletableFuture<AuthItClientHttpResponse<Void>> removeUserSession(String realm, String session) {
        return removeUserSession(
                realm, session, RemoveUserSessionRequest.builder().build());
    }

    /**
     * Remove a specific user session. Any client that has an admin url will also be told to invalidate this particular session.
     */
    public CompletableFuture<AuthItClientHttpResponse<Void>> removeUserSession(
            String realm, String session, RemoveUserSessionRequest request) {
        return removeUserSession(realm, session, request, null);
    }

    /**
     * Remove a specific user session. Any client that has an admin url will also be told to invalidate this particular session.
     */
    public CompletableFuture<AuthItClientHttpResponse<Void>> removeUserSession(
            String realm, String session, RemoveUserSessionRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("admin/realms")
                .addPathSegment(realm)
                .addPathSegments("sessions")
                .addPathSegment(session);
        if (request.getIsOffline().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "isOffline", request.getIsOffline().get().toString(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("DELETE", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<AuthItClientHttpResponse<Void>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new AuthItClientHttpResponse<>(null, response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 403:
                                future.completeExceptionally(new ForbiddenError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new AuthItApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new AuthItException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new AuthItException("Network error executing HTTP request", e));
            }
        });
        return future;
    }
}
